<?php
/**
 * ProfilesApi
 * PHP version 5
 *
 * @category Class
 * @package  Agave\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Agave Platform Science API
 *
 * Power your digital lab and reduce the time from theory to discovery using the Agave Science-as-a-Service API Platform. Agave provides hosted services that allow researchers to manage data, conduct experiments, and publish and share results from anywhere at any time.
 *
 * OpenAPI spec version: 2.2.14
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: unset
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Agave\Client\API;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Agave\Client\ApiException;
use Agave\Client\Configuration;
use Agave\Client\HeaderSelector;
use Agave\Client\ObjectSerializer;

/**
 * ProfilesApi Class Doc Comment
 *
 * @category Class
 * @package  Agave\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ProfilesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addInternalUser
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The internal user to create. (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\InternalUser
     */
    public function addInternalUser($api_username, $body, $naked = 'true')
    {
        list($response) = $this->addInternalUserWithHttpInfo($api_username, $body, $naked);
        return $response;
    }

    /**
     * Operation addInternalUserWithHttpInfo
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The internal user to create. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\InternalUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function addInternalUserWithHttpInfo($api_username, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser';
        $request = $this->addInternalUserRequest($api_username, $body, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\InternalUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addInternalUserAsync
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The internal user to create. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addInternalUserAsync($api_username, $body, $naked = 'true')
    {
        return $this->addInternalUserAsyncWithHttpInfo($api_username, $body, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addInternalUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The internal user to create. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addInternalUserAsyncWithHttpInfo($api_username, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser';
        $request = $this->addInternalUserRequest($api_username, $body, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addInternalUser'
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The internal user to create. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addInternalUserRequest($api_username, $body, $naked = 'true')
    {
        // verify the required parameter 'api_username' is set
        if ($api_username === null || (is_array($api_username) && count($api_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_username when calling addInternalUser'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling addInternalUser'
            );
        }

        $resourcePath = '/profiles/v2/{apiUsername}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($api_username !== null) {
            $resourcePath = str_replace(
                '{' . 'apiUsername' . '}',
                ObjectSerializer::toPathValue($api_username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addProfile
     *
     * @param  \Agave\Client\Model\Profile $body The user profile to add (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Profile
     */
    public function addProfile($body, $naked = 'true')
    {
        list($response) = $this->addProfileWithHttpInfo($body, $naked);
        return $response;
    }

    /**
     * Operation addProfileWithHttpInfo
     *
     * @param  \Agave\Client\Model\Profile $body The user profile to add (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Profile, HTTP status code, HTTP response headers (array of strings)
     */
    public function addProfileWithHttpInfo($body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Profile';
        $request = $this->addProfileRequest($body, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Profile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addProfileAsync
     *
     * 
     *
     * @param  \Agave\Client\Model\Profile $body The user profile to add (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addProfileAsync($body, $naked = 'true')
    {
        return $this->addProfileAsyncWithHttpInfo($body, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addProfileAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Agave\Client\Model\Profile $body The user profile to add (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addProfileAsyncWithHttpInfo($body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Profile';
        $request = $this->addProfileRequest($body, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addProfile'
     *
     * @param  \Agave\Client\Model\Profile $body The user profile to add (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addProfileRequest($body, $naked = 'true')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling addProfile'
            );
        }

        $resourcePath = '/profiles/v2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clearInternalUsers
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clearInternalUsers($api_username, $naked = 'true')
    {
        $this->clearInternalUsersWithHttpInfo($api_username, $naked);
    }

    /**
     * Operation clearInternalUsersWithHttpInfo
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clearInternalUsersWithHttpInfo($api_username, $naked = 'true')
    {
        $returnType = '';
        $request = $this->clearInternalUsersRequest($api_username, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clearInternalUsersAsync
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearInternalUsersAsync($api_username, $naked = 'true')
    {
        return $this->clearInternalUsersAsyncWithHttpInfo($api_username, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clearInternalUsersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearInternalUsersAsyncWithHttpInfo($api_username, $naked = 'true')
    {
        $returnType = '';
        $request = $this->clearInternalUsersRequest($api_username, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clearInternalUsers'
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clearInternalUsersRequest($api_username, $naked = 'true')
    {
        // verify the required parameter 'api_username' is set
        if ($api_username === null || (is_array($api_username) && count($api_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_username when calling clearInternalUsers'
            );
        }

        $resourcePath = '/profiles/v2/{apiUsername}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($api_username !== null) {
            $resourcePath = str_replace(
                '{' . 'apiUsername' . '}',
                ObjectSerializer::toPathValue($api_username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInternalUser
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\InternalUser
     */
    public function deleteInternalUser($api_username, $internal_username, $naked = 'true')
    {
        list($response) = $this->deleteInternalUserWithHttpInfo($api_username, $internal_username, $naked);
        return $response;
    }

    /**
     * Operation deleteInternalUserWithHttpInfo
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\InternalUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInternalUserWithHttpInfo($api_username, $internal_username, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser';
        $request = $this->deleteInternalUserRequest($api_username, $internal_username, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\InternalUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInternalUserAsync
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInternalUserAsync($api_username, $internal_username, $naked = 'true')
    {
        return $this->deleteInternalUserAsyncWithHttpInfo($api_username, $internal_username, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInternalUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInternalUserAsyncWithHttpInfo($api_username, $internal_username, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser';
        $request = $this->deleteInternalUserRequest($api_username, $internal_username, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInternalUser'
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteInternalUserRequest($api_username, $internal_username, $naked = 'true')
    {
        // verify the required parameter 'api_username' is set
        if ($api_username === null || (is_array($api_username) && count($api_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_username when calling deleteInternalUser'
            );
        }
        // verify the required parameter 'internal_username' is set
        if ($internal_username === null || (is_array($internal_username) && count($internal_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_username when calling deleteInternalUser'
            );
        }

        $resourcePath = '/profiles/v2/{apiUsername}/users/{internalUsername}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($api_username !== null) {
            $resourcePath = str_replace(
                '{' . 'apiUsername' . '}',
                ObjectSerializer::toPathValue($api_username),
                $resourcePath
            );
        }
        // path params
        if ($internal_username !== null) {
            $resourcePath = str_replace(
                '{' . 'internalUsername' . '}',
                ObjectSerializer::toPathValue($internal_username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProfile
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\EmptyClientResponse
     */
    public function deleteProfile($api_username, $filter = '*', $naked = 'true')
    {
        list($response) = $this->deleteProfileWithHttpInfo($api_username, $filter, $naked);
        return $response;
    }

    /**
     * Operation deleteProfileWithHttpInfo
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\EmptyClientResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProfileWithHttpInfo($api_username, $filter = '*', $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\EmptyClientResponse';
        $request = $this->deleteProfileRequest($api_username, $filter, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\EmptyClientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProfileAsync
     *
     * 
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfileAsync($api_username, $filter = '*', $naked = 'true')
    {
        return $this->deleteProfileAsyncWithHttpInfo($api_username, $filter, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProfileAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProfileAsyncWithHttpInfo($api_username, $filter = '*', $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\EmptyClientResponse';
        $request = $this->deleteProfileRequest($api_username, $filter, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProfile'
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteProfileRequest($api_username, $filter = '*', $naked = 'true')
    {
        // verify the required parameter 'api_username' is set
        if ($api_username === null || (is_array($api_username) && count($api_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_username when calling deleteProfile'
            );
        }

        $resourcePath = '/profiles/v2/{apiUsername}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($api_username !== null) {
            $resourcePath = str_replace(
                '{' . 'apiUsername' . '}',
                ObjectSerializer::toPathValue($api_username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInternalUser
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\InternalUser
     */
    public function getInternalUser($api_username, $internal_username, $naked = 'true')
    {
        list($response) = $this->getInternalUserWithHttpInfo($api_username, $internal_username, $naked);
        return $response;
    }

    /**
     * Operation getInternalUserWithHttpInfo
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\InternalUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInternalUserWithHttpInfo($api_username, $internal_username, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser';
        $request = $this->getInternalUserRequest($api_username, $internal_username, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\InternalUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInternalUserAsync
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInternalUserAsync($api_username, $internal_username, $naked = 'true')
    {
        return $this->getInternalUserAsyncWithHttpInfo($api_username, $internal_username, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInternalUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInternalUserAsyncWithHttpInfo($api_username, $internal_username, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser';
        $request = $this->getInternalUserRequest($api_username, $internal_username, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInternalUser'
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInternalUserRequest($api_username, $internal_username, $naked = 'true')
    {
        // verify the required parameter 'api_username' is set
        if ($api_username === null || (is_array($api_username) && count($api_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_username when calling getInternalUser'
            );
        }
        // verify the required parameter 'internal_username' is set
        if ($internal_username === null || (is_array($internal_username) && count($internal_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_username when calling getInternalUser'
            );
        }

        $resourcePath = '/profiles/v2/{apiUsername}/users/{internalUsername}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($api_username !== null) {
            $resourcePath = str_replace(
                '{' . 'apiUsername' . '}',
                ObjectSerializer::toPathValue($api_username),
                $resourcePath
            );
        }
        // path params
        if ($internal_username !== null) {
            $resourcePath = str_replace(
                '{' . 'internalUsername' . '}',
                ObjectSerializer::toPathValue($internal_username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProfile
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Profile
     */
    public function getProfile($api_username, $filter = '*', $naked = 'true')
    {
        list($response) = $this->getProfileWithHttpInfo($api_username, $filter, $naked);
        return $response;
    }

    /**
     * Operation getProfileWithHttpInfo
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Profile, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProfileWithHttpInfo($api_username, $filter = '*', $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Profile';
        $request = $this->getProfileRequest($api_username, $filter, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Profile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProfileAsync
     *
     * 
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsync($api_username, $filter = '*', $naked = 'true')
    {
        return $this->getProfileAsyncWithHttpInfo($api_username, $filter, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProfileAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsyncWithHttpInfo($api_username, $filter = '*', $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Profile';
        $request = $this->getProfileRequest($api_username, $filter, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProfile'
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  string $filter A comma-separated list of fields in the response objects to return. This allows developers to create their own response objects (optional, default to *)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProfileRequest($api_username, $filter = '*', $naked = 'true')
    {
        // verify the required parameter 'api_username' is set
        if ($api_username === null || (is_array($api_username) && count($api_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_username when calling getProfile'
            );
        }

        $resourcePath = '/profiles/v2/{apiUsername}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($api_username !== null) {
            $resourcePath = str_replace(
                '{' . 'apiUsername' . '}',
                ObjectSerializer::toPathValue($api_username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listInternalUsers
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $username The username of the internal user (optional)
     * @param  string $name The full name of the internal user (optional)
     * @param  string $email The email address of the internal user (optional)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\InternalUser[]
     */
    public function listInternalUsers($api_username, $username = null, $name = null, $email = null, $naked = 'true')
    {
        list($response) = $this->listInternalUsersWithHttpInfo($api_username, $username, $name, $email, $naked);
        return $response;
    }

    /**
     * Operation listInternalUsersWithHttpInfo
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $username The username of the internal user (optional)
     * @param  string $name The full name of the internal user (optional)
     * @param  string $email The email address of the internal user (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\InternalUser[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listInternalUsersWithHttpInfo($api_username, $username = null, $name = null, $email = null, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser[]';
        $request = $this->listInternalUsersRequest($api_username, $username, $name, $email, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\InternalUser[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listInternalUsersAsync
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $username The username of the internal user (optional)
     * @param  string $name The full name of the internal user (optional)
     * @param  string $email The email address of the internal user (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInternalUsersAsync($api_username, $username = null, $name = null, $email = null, $naked = 'true')
    {
        return $this->listInternalUsersAsyncWithHttpInfo($api_username, $username, $name, $email, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listInternalUsersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $username The username of the internal user (optional)
     * @param  string $name The full name of the internal user (optional)
     * @param  string $email The email address of the internal user (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInternalUsersAsyncWithHttpInfo($api_username, $username = null, $name = null, $email = null, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser[]';
        $request = $this->listInternalUsersRequest($api_username, $username, $name, $email, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listInternalUsers'
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $username The username of the internal user (optional)
     * @param  string $name The full name of the internal user (optional)
     * @param  string $email The email address of the internal user (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listInternalUsersRequest($api_username, $username = null, $name = null, $email = null, $naked = 'true')
    {
        // verify the required parameter 'api_username' is set
        if ($api_username === null || (is_array($api_username) && count($api_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_username when calling listInternalUsers'
            );
        }

        $resourcePath = '/profiles/v2/{apiUsername}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($username !== null) {
            $queryParams['username'] = ObjectSerializer::toQueryValue($username);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($api_username !== null) {
            $resourcePath = str_replace(
                '{' . 'apiUsername' . '}',
                ObjectSerializer::toPathValue($api_username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProfiles
     *
     * @param  string $username The username to search for (optional)
     * @param  string $name The user full name (optional)
     * @param  string $email The user email address (optional)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Profile[]
     */
    public function listProfiles($username = null, $name = null, $email = null, $naked = 'true')
    {
        list($response) = $this->listProfilesWithHttpInfo($username, $name, $email, $naked);
        return $response;
    }

    /**
     * Operation listProfilesWithHttpInfo
     *
     * @param  string $username The username to search for (optional)
     * @param  string $name The user full name (optional)
     * @param  string $email The user email address (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Profile[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listProfilesWithHttpInfo($username = null, $name = null, $email = null, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Profile[]';
        $request = $this->listProfilesRequest($username, $name, $email, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Profile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProfilesAsync
     *
     * 
     *
     * @param  string $username The username to search for (optional)
     * @param  string $name The user full name (optional)
     * @param  string $email The user email address (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProfilesAsync($username = null, $name = null, $email = null, $naked = 'true')
    {
        return $this->listProfilesAsyncWithHttpInfo($username, $name, $email, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProfilesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $username The username to search for (optional)
     * @param  string $name The user full name (optional)
     * @param  string $email The user email address (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProfilesAsyncWithHttpInfo($username = null, $name = null, $email = null, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Profile[]';
        $request = $this->listProfilesRequest($username, $name, $email, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProfiles'
     *
     * @param  string $username The username to search for (optional)
     * @param  string $name The user full name (optional)
     * @param  string $email The user email address (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listProfilesRequest($username = null, $name = null, $email = null, $naked = 'true')
    {

        $resourcePath = '/profiles/v2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($username !== null) {
            $queryParams['username'] = ObjectSerializer::toQueryValue($username);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateInternalUser
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body A JSON description of the internal user to update (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\InternalUser
     */
    public function updateInternalUser($api_username, $internal_username, $body, $naked = 'true')
    {
        list($response) = $this->updateInternalUserWithHttpInfo($api_username, $internal_username, $body, $naked);
        return $response;
    }

    /**
     * Operation updateInternalUserWithHttpInfo
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body A JSON description of the internal user to update (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\InternalUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInternalUserWithHttpInfo($api_username, $internal_username, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser';
        $request = $this->updateInternalUserRequest($api_username, $internal_username, $body, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\InternalUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateInternalUserAsync
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body A JSON description of the internal user to update (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInternalUserAsync($api_username, $internal_username, $body, $naked = 'true')
    {
        return $this->updateInternalUserAsyncWithHttpInfo($api_username, $internal_username, $body, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateInternalUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body A JSON description of the internal user to update (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInternalUserAsyncWithHttpInfo($api_username, $internal_username, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\InternalUser';
        $request = $this->updateInternalUserRequest($api_username, $internal_username, $body, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateInternalUser'
     *
     * @param  string $api_username The username of a valid api user (required)
     * @param  string $internal_username The username of a valid internal user (required)
     * @param  \Agave\Client\Model\ProfileRequest $body A JSON description of the internal user to update (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateInternalUserRequest($api_username, $internal_username, $body, $naked = 'true')
    {
        // verify the required parameter 'api_username' is set
        if ($api_username === null || (is_array($api_username) && count($api_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_username when calling updateInternalUser'
            );
        }
        // verify the required parameter 'internal_username' is set
        if ($internal_username === null || (is_array($internal_username) && count($internal_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_username when calling updateInternalUser'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateInternalUser'
            );
        }

        $resourcePath = '/profiles/v2/{apiUsername}/users/{internalUsername}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($api_username !== null) {
            $resourcePath = str_replace(
                '{' . 'apiUsername' . '}',
                ObjectSerializer::toPathValue($api_username),
                $resourcePath
            );
        }
        // path params
        if ($internal_username !== null) {
            $resourcePath = str_replace(
                '{' . 'internalUsername' . '}',
                ObjectSerializer::toPathValue($internal_username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProfile
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The updated profile (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Profile
     */
    public function updateProfile($api_username, $body, $naked = 'true')
    {
        list($response) = $this->updateProfileWithHttpInfo($api_username, $body, $naked);
        return $response;
    }

    /**
     * Operation updateProfileWithHttpInfo
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The updated profile (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Profile, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProfileWithHttpInfo($api_username, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Profile';
        $request = $this->updateProfileRequest($api_username, $body, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Profile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProfileAsync
     *
     * 
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The updated profile (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProfileAsync($api_username, $body, $naked = 'true')
    {
        return $this->updateProfileAsyncWithHttpInfo($api_username, $body, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProfileAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The updated profile (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProfileAsyncWithHttpInfo($api_username, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Profile';
        $request = $this->updateProfileRequest($api_username, $body, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProfile'
     *
     * @param  string $api_username The username of the profile to update (required)
     * @param  \Agave\Client\Model\ProfileRequest $body The updated profile (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateProfileRequest($api_username, $body, $naked = 'true')
    {
        // verify the required parameter 'api_username' is set
        if ($api_username === null || (is_array($api_username) && count($api_username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_username when calling updateProfile'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateProfile'
            );
        }

        $resourcePath = '/profiles/v2/{apiUsername}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($api_username !== null) {
            $resourcePath = str_replace(
                '{' . 'apiUsername' . '}',
                ObjectSerializer::toPathValue($api_username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
