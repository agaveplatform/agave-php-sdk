<?php
/**
 * JobsApi
 * PHP version 5
 *
 * @category Class
 * @package  Agave\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Agave Platform Science API
 *
 * Power your digital lab and reduce the time from theory to discovery using the Agave Science-as-a-Service API Platform. Agave provides hosted services that allow researchers to manage data, conduct experiments, and publish and share results from anywhere at any time.
 *
 * OpenAPI spec version: 2.2.14
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: unset
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Agave\Client\API;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Agave\Client\ApiException;
use Agave\Client\Configuration;
use Agave\Client\HeaderSelector;
use Agave\Client\ObjectSerializer;

/**
 * JobsApi Class Doc Comment
 *
 * @category Class
 * @package  Agave\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class JobsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addJobPermission
     *
     * @param  string $job_id The id of the job. (required)
     * @param  \Agave\Client\Model\Permission $body The permission add or update. (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Permission
     */
    public function addJobPermission($job_id, $body, $naked = 'true')
    {
        list($response) = $this->addJobPermissionWithHttpInfo($job_id, $body, $naked);
        return $response;
    }

    /**
     * Operation addJobPermissionWithHttpInfo
     *
     * @param  string $job_id The id of the job. (required)
     * @param  \Agave\Client\Model\Permission $body The permission add or update. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Permission, HTTP status code, HTTP response headers (array of strings)
     */
    public function addJobPermissionWithHttpInfo($job_id, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Permission';
        $request = $this->addJobPermissionRequest($job_id, $body, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Permission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addJobPermissionAsync
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  \Agave\Client\Model\Permission $body The permission add or update. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addJobPermissionAsync($job_id, $body, $naked = 'true')
    {
        return $this->addJobPermissionAsyncWithHttpInfo($job_id, $body, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addJobPermissionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  \Agave\Client\Model\Permission $body The permission add or update. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addJobPermissionAsyncWithHttpInfo($job_id, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Permission';
        $request = $this->addJobPermissionRequest($job_id, $body, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addJobPermission'
     *
     * @param  string $job_id The id of the job. (required)
     * @param  \Agave\Client\Model\Permission $body The permission add or update. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addJobPermissionRequest($job_id, $body, $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling addJobPermission'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling addJobPermission'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/pems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clearJobPermissions
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clearJobPermissions($job_id, $naked = 'true')
    {
        $this->clearJobPermissionsWithHttpInfo($job_id, $naked);
    }

    /**
     * Operation clearJobPermissionsWithHttpInfo
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clearJobPermissionsWithHttpInfo($job_id, $naked = 'true')
    {
        $returnType = '';
        $request = $this->clearJobPermissionsRequest($job_id, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clearJobPermissionsAsync
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearJobPermissionsAsync($job_id, $naked = 'true')
    {
        return $this->clearJobPermissionsAsyncWithHttpInfo($job_id, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clearJobPermissionsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearJobPermissionsAsyncWithHttpInfo($job_id, $naked = 'true')
    {
        $returnType = '';
        $request = $this->clearJobPermissionsRequest($job_id, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clearJobPermissions'
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clearJobPermissionsRequest($job_id, $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling clearJobPermissions'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/pems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteJob
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteJob($job_id, $naked = 'true')
    {
        $this->deleteJobWithHttpInfo($job_id, $naked);
    }

    /**
     * Operation deleteJobWithHttpInfo
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteJobWithHttpInfo($job_id, $naked = 'true')
    {
        $returnType = '';
        $request = $this->deleteJobRequest($job_id, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteJobAsync
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteJobAsync($job_id, $naked = 'true')
    {
        return $this->deleteJobAsyncWithHttpInfo($job_id, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteJobAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteJobAsyncWithHttpInfo($job_id, $naked = 'true')
    {
        $returnType = '';
        $request = $this->deleteJobRequest($job_id, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteJob'
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteJobRequest($job_id, $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling deleteJob'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteJobPermission
     *
     * @param  string $job_id The id of the job for which to delete the user permissions. (required)
     * @param  string $username The username for whom to delete permissions (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteJobPermission($job_id, $username, $naked = 'true')
    {
        $this->deleteJobPermissionWithHttpInfo($job_id, $username, $naked);
    }

    /**
     * Operation deleteJobPermissionWithHttpInfo
     *
     * @param  string $job_id The id of the job for which to delete the user permissions. (required)
     * @param  string $username The username for whom to delete permissions (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteJobPermissionWithHttpInfo($job_id, $username, $naked = 'true')
    {
        $returnType = '';
        $request = $this->deleteJobPermissionRequest($job_id, $username, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteJobPermissionAsync
     *
     * 
     *
     * @param  string $job_id The id of the job for which to delete the user permissions. (required)
     * @param  string $username The username for whom to delete permissions (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteJobPermissionAsync($job_id, $username, $naked = 'true')
    {
        return $this->deleteJobPermissionAsyncWithHttpInfo($job_id, $username, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteJobPermissionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job for which to delete the user permissions. (required)
     * @param  string $username The username for whom to delete permissions (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteJobPermissionAsyncWithHttpInfo($job_id, $username, $naked = 'true')
    {
        $returnType = '';
        $request = $this->deleteJobPermissionRequest($job_id, $username, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteJobPermission'
     *
     * @param  string $job_id The id of the job for which to delete the user permissions. (required)
     * @param  string $username The username for whom to delete permissions (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteJobPermissionRequest($job_id, $username, $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling deleteJobPermission'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling deleteJobPermission'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/pems/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadJobOutput
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file relative to the job output directory. (required)
     * @param  bool $force If true, the Content-Disposition header is set to force a file download from the browser. (required)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function downloadJobOutput($job_id, $file_path, $force)
    {
        $this->downloadJobOutputWithHttpInfo($job_id, $file_path, $force);
    }

    /**
     * Operation downloadJobOutputWithHttpInfo
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file relative to the job output directory. (required)
     * @param  bool $force If true, the Content-Disposition header is set to force a file download from the browser. (required)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadJobOutputWithHttpInfo($job_id, $file_path, $force)
    {
        $returnType = '';
        $request = $this->downloadJobOutputRequest($job_id, $file_path, $force);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation downloadJobOutputAsync
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file relative to the job output directory. (required)
     * @param  bool $force If true, the Content-Disposition header is set to force a file download from the browser. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadJobOutputAsync($job_id, $file_path, $force)
    {
        return $this->downloadJobOutputAsyncWithHttpInfo($job_id, $file_path, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadJobOutputAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file relative to the job output directory. (required)
     * @param  bool $force If true, the Content-Disposition header is set to force a file download from the browser. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadJobOutputAsyncWithHttpInfo($job_id, $file_path, $force)
    {
        $returnType = '';
        $request = $this->downloadJobOutputRequest($job_id, $file_path, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadJobOutput'
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file relative to the job output directory. (required)
     * @param  bool $force If true, the Content-Disposition header is set to force a file download from the browser. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadJobOutputRequest($job_id, $file_path, $force)
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling downloadJobOutput'
            );
        }
        // verify the required parameter 'file_path' is set
        if ($file_path === null || (is_array($file_path) && count($file_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_path when calling downloadJobOutput'
            );
        }
        // verify the required parameter 'force' is set
        if ($force === null || (is_array($force) && count($force) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $force when calling downloadJobOutput'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/outputs/media/{filePath}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }
        // path params
        if ($file_path !== null) {
            $resourcePath = str_replace(
                '{' . 'filePath' . '}',
                ObjectSerializer::toPathValue($file_path),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getJobDetails
     *
     * @param  int $job_id The id of the job. (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Job
     */
    public function getJobDetails($job_id, $naked = 'true')
    {
        list($response) = $this->getJobDetailsWithHttpInfo($job_id, $naked);
        return $response;
    }

    /**
     * Operation getJobDetailsWithHttpInfo
     *
     * @param  int $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Job, HTTP status code, HTTP response headers (array of strings)
     */
    public function getJobDetailsWithHttpInfo($job_id, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Job';
        $request = $this->getJobDetailsRequest($job_id, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Job',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getJobDetailsAsync
     *
     * 
     *
     * @param  int $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJobDetailsAsync($job_id, $naked = 'true')
    {
        return $this->getJobDetailsAsyncWithHttpInfo($job_id, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getJobDetailsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJobDetailsAsyncWithHttpInfo($job_id, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Job';
        $request = $this->getJobDetailsRequest($job_id, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getJobDetails'
     *
     * @param  int $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getJobDetailsRequest($job_id, $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling getJobDetails'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getJobHistory
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\JobHistory[]
     */
    public function getJobHistory($job_id, $naked = 'true', $limit = '100', $offset = '0')
    {
        list($response) = $this->getJobHistoryWithHttpInfo($job_id, $naked, $limit, $offset);
        return $response;
    }

    /**
     * Operation getJobHistoryWithHttpInfo
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\JobHistory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getJobHistoryWithHttpInfo($job_id, $naked = 'true', $limit = '100', $offset = '0')
    {
        $returnType = '\Agave\Client\Model\JobHistory[]';
        $request = $this->getJobHistoryRequest($job_id, $naked, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\JobHistory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getJobHistoryAsync
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJobHistoryAsync($job_id, $naked = 'true', $limit = '100', $offset = '0')
    {
        return $this->getJobHistoryAsyncWithHttpInfo($job_id, $naked, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getJobHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJobHistoryAsyncWithHttpInfo($job_id, $naked = 'true', $limit = '100', $offset = '0')
    {
        $returnType = '\Agave\Client\Model\JobHistory[]';
        $request = $this->getJobHistoryRequest($job_id, $naked, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getJobHistory'
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getJobHistoryRequest($job_id, $naked = 'true', $limit = '100', $offset = '0')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling getJobHistory'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getJobPermission
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $username The username of the api user associated with the permission. (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Permission
     */
    public function getJobPermission($job_id, $username, $naked = 'true')
    {
        list($response) = $this->getJobPermissionWithHttpInfo($job_id, $username, $naked);
        return $response;
    }

    /**
     * Operation getJobPermissionWithHttpInfo
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $username The username of the api user associated with the permission. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Permission, HTTP status code, HTTP response headers (array of strings)
     */
    public function getJobPermissionWithHttpInfo($job_id, $username, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Permission';
        $request = $this->getJobPermissionRequest($job_id, $username, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Permission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getJobPermissionAsync
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $username The username of the api user associated with the permission. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJobPermissionAsync($job_id, $username, $naked = 'true')
    {
        return $this->getJobPermissionAsyncWithHttpInfo($job_id, $username, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getJobPermissionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $username The username of the api user associated with the permission. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJobPermissionAsyncWithHttpInfo($job_id, $username, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Permission';
        $request = $this->getJobPermissionRequest($job_id, $username, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getJobPermission'
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $username The username of the api user associated with the permission. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getJobPermissionRequest($job_id, $username, $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling getJobPermission'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling getJobPermission'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/pems/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getJobStatus
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\JobStatusSummary
     */
    public function getJobStatus($job_id, $naked = 'true')
    {
        list($response) = $this->getJobStatusWithHttpInfo($job_id, $naked);
        return $response;
    }

    /**
     * Operation getJobStatusWithHttpInfo
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\JobStatusSummary, HTTP status code, HTTP response headers (array of strings)
     */
    public function getJobStatusWithHttpInfo($job_id, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\JobStatusSummary';
        $request = $this->getJobStatusRequest($job_id, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\JobStatusSummary',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getJobStatusAsync
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJobStatusAsync($job_id, $naked = 'true')
    {
        return $this->getJobStatusAsyncWithHttpInfo($job_id, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getJobStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJobStatusAsyncWithHttpInfo($job_id, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\JobStatusSummary';
        $request = $this->getJobStatusRequest($job_id, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getJobStatus'
     *
     * @param  string $job_id The id of the job. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getJobStatusRequest($job_id, $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling getJobStatus'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listJobOutputs
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file or folder relative to the job output directory. This resource will follow data around as it moves from the execution system to archival storage. (required)
     * @param  bool $naked naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\FileInfo[]
     */
    public function listJobOutputs($job_id, $file_path, $naked = 'true', $limit = '100', $offset = '0')
    {
        list($response) = $this->listJobOutputsWithHttpInfo($job_id, $file_path, $naked, $limit, $offset);
        return $response;
    }

    /**
     * Operation listJobOutputsWithHttpInfo
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file or folder relative to the job output directory. This resource will follow data around as it moves from the execution system to archival storage. (required)
     * @param  bool $naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\FileInfo[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listJobOutputsWithHttpInfo($job_id, $file_path, $naked = 'true', $limit = '100', $offset = '0')
    {
        $returnType = '\Agave\Client\Model\FileInfo[]';
        $request = $this->listJobOutputsRequest($job_id, $file_path, $naked, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\FileInfo[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listJobOutputsAsync
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file or folder relative to the job output directory. This resource will follow data around as it moves from the execution system to archival storage. (required)
     * @param  bool $naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listJobOutputsAsync($job_id, $file_path, $naked = 'true', $limit = '100', $offset = '0')
    {
        return $this->listJobOutputsAsyncWithHttpInfo($job_id, $file_path, $naked, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listJobOutputsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file or folder relative to the job output directory. This resource will follow data around as it moves from the execution system to archival storage. (required)
     * @param  bool $naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listJobOutputsAsyncWithHttpInfo($job_id, $file_path, $naked = 'true', $limit = '100', $offset = '0')
    {
        $returnType = '\Agave\Client\Model\FileInfo[]';
        $request = $this->listJobOutputsRequest($job_id, $file_path, $naked, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listJobOutputs'
     *
     * @param  string $job_id The id of the job. (required)
     * @param  string $file_path The path to an output file or folder relative to the job output directory. This resource will follow data around as it moves from the execution system to archival storage. (required)
     * @param  bool $naked (optional, default to true)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results skipped in the result set returned from this query (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listJobOutputsRequest($job_id, $file_path, $naked = 'true', $limit = '100', $offset = '0')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling listJobOutputs'
            );
        }
        // verify the required parameter 'file_path' is set
        if ($file_path === null || (is_array($file_path) && count($file_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_path when calling listJobOutputs'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/outputs/listings/{filePath}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }
        // path params
        if ($file_path !== null) {
            $resourcePath = str_replace(
                '{' . 'filePath' . '}',
                ObjectSerializer::toPathValue($file_path),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listJobPermissions
     *
     * @param  string $job_id The id of the job. (required)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results to skip in the result set for this query (optional, default to 0)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Permission[]
     */
    public function listJobPermissions($job_id, $limit = '100', $offset = '0', $naked = 'true')
    {
        list($response) = $this->listJobPermissionsWithHttpInfo($job_id, $limit, $offset, $naked);
        return $response;
    }

    /**
     * Operation listJobPermissionsWithHttpInfo
     *
     * @param  string $job_id The id of the job. (required)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results to skip in the result set for this query (optional, default to 0)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Permission[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listJobPermissionsWithHttpInfo($job_id, $limit = '100', $offset = '0', $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Permission[]';
        $request = $this->listJobPermissionsRequest($job_id, $limit, $offset, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Permission[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listJobPermissionsAsync
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results to skip in the result set for this query (optional, default to 0)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listJobPermissionsAsync($job_id, $limit = '100', $offset = '0', $naked = 'true')
    {
        return $this->listJobPermissionsAsyncWithHttpInfo($job_id, $limit, $offset, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listJobPermissionsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job. (required)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results to skip in the result set for this query (optional, default to 0)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listJobPermissionsAsyncWithHttpInfo($job_id, $limit = '100', $offset = '0', $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Permission[]';
        $request = $this->listJobPermissionsRequest($job_id, $limit, $offset, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listJobPermissions'
     *
     * @param  string $job_id The id of the job. (required)
     * @param  int $limit The maximum number of results returned from this query (optional, default to 100)
     * @param  int $offset The number of results to skip in the result set for this query (optional, default to 0)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listJobPermissionsRequest($job_id, $limit = '100', $offset = '0', $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling listJobPermissions'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/pems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listJobs
     *
     * @param  string $app_id The id of the app run by the job. (optional)
     * @param  string $archive Boolean flag stating whether the job output was archived. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  string $archive_path Path on the archive system where the job output was archived if the archive flag was true. (optional)
     * @param  string $archive_system The id of the system where the job output was archived if the archive flag was true. (optional)
     * @param  string $batch_queue The system queue in which the job ran. (optional)
     * @param  string $execution_system The execution system where the job ran. (optional)
     * @param  string $id The id of the job. (optional)
     * @param  string $inputs The job inputs. Note, this is a partial text search. (optional)
     * @param  string $local_id The local job id of the job on the execution system. (optional)
     * @param  string $max_runtime The maximum run time of the job in HH:mm:ss format. (optional)
     * @param  string $memory_per_node The memory requested by the job specified in GB. (optional)
     * @param  string $name The name of the job. (optional)
     * @param  int $node_count The number of nodes requested for the job. (optional)
     * @param  string $output_path The remote work directory path of the job. (optional)
     * @param  string $parameters The job parameters. Note, this is a partial text search. (optional)
     * @param  int $processors_per_node The number of processors per node requested by the job. (optional)
     * @param  int $retries The number of retry attempts made on this job. (optional)
     * @param  string $start_time The date the job began running. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $status The job status. (optional)
     * @param  string $submit_time The date the job was submitted to the remote execution system to run. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $visible Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  int $limit Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  int $offset Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Job[]
     */
    public function listJobs($app_id = null, $archive = 'true', $archive_path = null, $archive_system = null, $batch_queue = null, $execution_system = null, $id = null, $inputs = null, $local_id = null, $max_runtime = null, $memory_per_node = null, $name = null, $node_count = null, $output_path = null, $parameters = null, $processors_per_node = null, $retries = null, $start_time = null, $status = null, $submit_time = null, $visible = 'true', $limit = null, $offset = null, $naked = 'true')
    {
        list($response) = $this->listJobsWithHttpInfo($app_id, $archive, $archive_path, $archive_system, $batch_queue, $execution_system, $id, $inputs, $local_id, $max_runtime, $memory_per_node, $name, $node_count, $output_path, $parameters, $processors_per_node, $retries, $start_time, $status, $submit_time, $visible, $limit, $offset, $naked);
        return $response;
    }

    /**
     * Operation listJobsWithHttpInfo
     *
     * @param  string $app_id The id of the app run by the job. (optional)
     * @param  string $archive Boolean flag stating whether the job output was archived. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  string $archive_path Path on the archive system where the job output was archived if the archive flag was true. (optional)
     * @param  string $archive_system The id of the system where the job output was archived if the archive flag was true. (optional)
     * @param  string $batch_queue The system queue in which the job ran. (optional)
     * @param  string $execution_system The execution system where the job ran. (optional)
     * @param  string $id The id of the job. (optional)
     * @param  string $inputs The job inputs. Note, this is a partial text search. (optional)
     * @param  string $local_id The local job id of the job on the execution system. (optional)
     * @param  string $max_runtime The maximum run time of the job in HH:mm:ss format. (optional)
     * @param  string $memory_per_node The memory requested by the job specified in GB. (optional)
     * @param  string $name The name of the job. (optional)
     * @param  int $node_count The number of nodes requested for the job. (optional)
     * @param  string $output_path The remote work directory path of the job. (optional)
     * @param  string $parameters The job parameters. Note, this is a partial text search. (optional)
     * @param  int $processors_per_node The number of processors per node requested by the job. (optional)
     * @param  int $retries The number of retry attempts made on this job. (optional)
     * @param  string $start_time The date the job began running. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $status The job status. (optional)
     * @param  string $submit_time The date the job was submitted to the remote execution system to run. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $visible Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  int $limit Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  int $offset Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Job[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listJobsWithHttpInfo($app_id = null, $archive = 'true', $archive_path = null, $archive_system = null, $batch_queue = null, $execution_system = null, $id = null, $inputs = null, $local_id = null, $max_runtime = null, $memory_per_node = null, $name = null, $node_count = null, $output_path = null, $parameters = null, $processors_per_node = null, $retries = null, $start_time = null, $status = null, $submit_time = null, $visible = 'true', $limit = null, $offset = null, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Job[]';
        $request = $this->listJobsRequest($app_id, $archive, $archive_path, $archive_system, $batch_queue, $execution_system, $id, $inputs, $local_id, $max_runtime, $memory_per_node, $name, $node_count, $output_path, $parameters, $processors_per_node, $retries, $start_time, $status, $submit_time, $visible, $limit, $offset, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Job[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listJobsAsync
     *
     * 
     *
     * @param  string $app_id The id of the app run by the job. (optional)
     * @param  string $archive Boolean flag stating whether the job output was archived. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  string $archive_path Path on the archive system where the job output was archived if the archive flag was true. (optional)
     * @param  string $archive_system The id of the system where the job output was archived if the archive flag was true. (optional)
     * @param  string $batch_queue The system queue in which the job ran. (optional)
     * @param  string $execution_system The execution system where the job ran. (optional)
     * @param  string $id The id of the job. (optional)
     * @param  string $inputs The job inputs. Note, this is a partial text search. (optional)
     * @param  string $local_id The local job id of the job on the execution system. (optional)
     * @param  string $max_runtime The maximum run time of the job in HH:mm:ss format. (optional)
     * @param  string $memory_per_node The memory requested by the job specified in GB. (optional)
     * @param  string $name The name of the job. (optional)
     * @param  int $node_count The number of nodes requested for the job. (optional)
     * @param  string $output_path The remote work directory path of the job. (optional)
     * @param  string $parameters The job parameters. Note, this is a partial text search. (optional)
     * @param  int $processors_per_node The number of processors per node requested by the job. (optional)
     * @param  int $retries The number of retry attempts made on this job. (optional)
     * @param  string $start_time The date the job began running. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $status The job status. (optional)
     * @param  string $submit_time The date the job was submitted to the remote execution system to run. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $visible Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  int $limit Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  int $offset Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listJobsAsync($app_id = null, $archive = 'true', $archive_path = null, $archive_system = null, $batch_queue = null, $execution_system = null, $id = null, $inputs = null, $local_id = null, $max_runtime = null, $memory_per_node = null, $name = null, $node_count = null, $output_path = null, $parameters = null, $processors_per_node = null, $retries = null, $start_time = null, $status = null, $submit_time = null, $visible = 'true', $limit = null, $offset = null, $naked = 'true')
    {
        return $this->listJobsAsyncWithHttpInfo($app_id, $archive, $archive_path, $archive_system, $batch_queue, $execution_system, $id, $inputs, $local_id, $max_runtime, $memory_per_node, $name, $node_count, $output_path, $parameters, $processors_per_node, $retries, $start_time, $status, $submit_time, $visible, $limit, $offset, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listJobsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_id The id of the app run by the job. (optional)
     * @param  string $archive Boolean flag stating whether the job output was archived. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  string $archive_path Path on the archive system where the job output was archived if the archive flag was true. (optional)
     * @param  string $archive_system The id of the system where the job output was archived if the archive flag was true. (optional)
     * @param  string $batch_queue The system queue in which the job ran. (optional)
     * @param  string $execution_system The execution system where the job ran. (optional)
     * @param  string $id The id of the job. (optional)
     * @param  string $inputs The job inputs. Note, this is a partial text search. (optional)
     * @param  string $local_id The local job id of the job on the execution system. (optional)
     * @param  string $max_runtime The maximum run time of the job in HH:mm:ss format. (optional)
     * @param  string $memory_per_node The memory requested by the job specified in GB. (optional)
     * @param  string $name The name of the job. (optional)
     * @param  int $node_count The number of nodes requested for the job. (optional)
     * @param  string $output_path The remote work directory path of the job. (optional)
     * @param  string $parameters The job parameters. Note, this is a partial text search. (optional)
     * @param  int $processors_per_node The number of processors per node requested by the job. (optional)
     * @param  int $retries The number of retry attempts made on this job. (optional)
     * @param  string $start_time The date the job began running. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $status The job status. (optional)
     * @param  string $submit_time The date the job was submitted to the remote execution system to run. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $visible Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  int $limit Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  int $offset Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listJobsAsyncWithHttpInfo($app_id = null, $archive = 'true', $archive_path = null, $archive_system = null, $batch_queue = null, $execution_system = null, $id = null, $inputs = null, $local_id = null, $max_runtime = null, $memory_per_node = null, $name = null, $node_count = null, $output_path = null, $parameters = null, $processors_per_node = null, $retries = null, $start_time = null, $status = null, $submit_time = null, $visible = 'true', $limit = null, $offset = null, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Job[]';
        $request = $this->listJobsRequest($app_id, $archive, $archive_path, $archive_system, $batch_queue, $execution_system, $id, $inputs, $local_id, $max_runtime, $memory_per_node, $name, $node_count, $output_path, $parameters, $processors_per_node, $retries, $start_time, $status, $submit_time, $visible, $limit, $offset, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listJobs'
     *
     * @param  string $app_id The id of the app run by the job. (optional)
     * @param  string $archive Boolean flag stating whether the job output was archived. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  string $archive_path Path on the archive system where the job output was archived if the archive flag was true. (optional)
     * @param  string $archive_system The id of the system where the job output was archived if the archive flag was true. (optional)
     * @param  string $batch_queue The system queue in which the job ran. (optional)
     * @param  string $execution_system The execution system where the job ran. (optional)
     * @param  string $id The id of the job. (optional)
     * @param  string $inputs The job inputs. Note, this is a partial text search. (optional)
     * @param  string $local_id The local job id of the job on the execution system. (optional)
     * @param  string $max_runtime The maximum run time of the job in HH:mm:ss format. (optional)
     * @param  string $memory_per_node The memory requested by the job specified in GB. (optional)
     * @param  string $name The name of the job. (optional)
     * @param  int $node_count The number of nodes requested for the job. (optional)
     * @param  string $output_path The remote work directory path of the job. (optional)
     * @param  string $parameters The job parameters. Note, this is a partial text search. (optional)
     * @param  int $processors_per_node The number of processors per node requested by the job. (optional)
     * @param  int $retries The number of retry attempts made on this job. (optional)
     * @param  string $start_time The date the job began running. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $status The job status. (optional)
     * @param  string $submit_time The date the job was submitted to the remote execution system to run. Results are rounded by day. You may specify using YYYY-MM-DD format or free form timeframes such as &#39;yesterday&#39; or &#39;3 days ago&#39;. (optional)
     * @param  string $visible Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (Acceptable values are: \&quot;true\&quot;, \&quot;false\&quot;) (optional, default to true)
     * @param  int $limit Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  int $offset Boolean flag indicating whether or not to show deleted jobs. Defaults to false. (optional)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listJobsRequest($app_id = null, $archive = 'true', $archive_path = null, $archive_system = null, $batch_queue = null, $execution_system = null, $id = null, $inputs = null, $local_id = null, $max_runtime = null, $memory_per_node = null, $name = null, $node_count = null, $output_path = null, $parameters = null, $processors_per_node = null, $retries = null, $start_time = null, $status = null, $submit_time = null, $visible = 'true', $limit = null, $offset = null, $naked = 'true')
    {

        $resourcePath = '/jobs/v2/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($app_id !== null) {
            $queryParams['appId'] = ObjectSerializer::toQueryValue($app_id);
        }
        // query params
        if ($archive !== null) {
            $queryParams['archive'] = ObjectSerializer::toQueryValue($archive);
        }
        // query params
        if ($archive_path !== null) {
            $queryParams['archivePath'] = ObjectSerializer::toQueryValue($archive_path);
        }
        // query params
        if ($archive_system !== null) {
            $queryParams['archiveSystem'] = ObjectSerializer::toQueryValue($archive_system);
        }
        // query params
        if ($batch_queue !== null) {
            $queryParams['batchQueue'] = ObjectSerializer::toQueryValue($batch_queue);
        }
        // query params
        if ($execution_system !== null) {
            $queryParams['executionSystem'] = ObjectSerializer::toQueryValue($execution_system);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($inputs !== null) {
            $queryParams['inputs'] = ObjectSerializer::toQueryValue($inputs);
        }
        // query params
        if ($local_id !== null) {
            $queryParams['localId'] = ObjectSerializer::toQueryValue($local_id);
        }
        // query params
        if ($max_runtime !== null) {
            $queryParams['maxRuntime'] = ObjectSerializer::toQueryValue($max_runtime);
        }
        // query params
        if ($memory_per_node !== null) {
            $queryParams['memoryPerNode'] = ObjectSerializer::toQueryValue($memory_per_node);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($node_count !== null) {
            $queryParams['nodeCount'] = ObjectSerializer::toQueryValue($node_count);
        }
        // query params
        if ($output_path !== null) {
            $queryParams['outputPath'] = ObjectSerializer::toQueryValue($output_path);
        }
        // query params
        if ($parameters !== null) {
            $queryParams['parameters'] = ObjectSerializer::toQueryValue($parameters);
        }
        // query params
        if ($processors_per_node !== null) {
            $queryParams['processorsPerNode'] = ObjectSerializer::toQueryValue($processors_per_node);
        }
        // query params
        if ($retries !== null) {
            $queryParams['retries'] = ObjectSerializer::toQueryValue($retries);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = ObjectSerializer::toQueryValue($start_time);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($submit_time !== null) {
            $queryParams['submitTime'] = ObjectSerializer::toQueryValue($submit_time);
        }
        // query params
        if ($visible !== null) {
            $queryParams['visible'] = ObjectSerializer::toQueryValue($visible);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resubmitJob
     *
     * @param  string $job_id The id of the job to resubmit (required)
     * @param  \Agave\Client\Model\JobResubmitAction $body The resubmit action request (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Job
     */
    public function resubmitJob($job_id, $body, $naked = 'true')
    {
        list($response) = $this->resubmitJobWithHttpInfo($job_id, $body, $naked);
        return $response;
    }

    /**
     * Operation resubmitJobWithHttpInfo
     *
     * @param  string $job_id The id of the job to resubmit (required)
     * @param  \Agave\Client\Model\JobResubmitAction $body The resubmit action request (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Job, HTTP status code, HTTP response headers (array of strings)
     */
    public function resubmitJobWithHttpInfo($job_id, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Job';
        $request = $this->resubmitJobRequest($job_id, $body, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Job',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resubmitJobAsync
     *
     * 
     *
     * @param  string $job_id The id of the job to resubmit (required)
     * @param  \Agave\Client\Model\JobResubmitAction $body The resubmit action request (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resubmitJobAsync($job_id, $body, $naked = 'true')
    {
        return $this->resubmitJobAsyncWithHttpInfo($job_id, $body, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resubmitJobAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job to resubmit (required)
     * @param  \Agave\Client\Model\JobResubmitAction $body The resubmit action request (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resubmitJobAsyncWithHttpInfo($job_id, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Job';
        $request = $this->resubmitJobRequest($job_id, $body, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resubmitJob'
     *
     * @param  string $job_id The id of the job to resubmit (required)
     * @param  \Agave\Client\Model\JobResubmitAction $body The resubmit action request (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resubmitJobRequest($job_id, $body, $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling resubmitJob'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling resubmitJob'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submitJob
     *
     * @param  \Agave\Client\Model\JobRequest $body The JSON description of the job to submit. (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Job
     */
    public function submitJob($body, $naked = 'true')
    {
        list($response) = $this->submitJobWithHttpInfo($body, $naked);
        return $response;
    }

    /**
     * Operation submitJobWithHttpInfo
     *
     * @param  \Agave\Client\Model\JobRequest $body The JSON description of the job to submit. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Job, HTTP status code, HTTP response headers (array of strings)
     */
    public function submitJobWithHttpInfo($body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Job';
        $request = $this->submitJobRequest($body, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Job',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation submitJobAsync
     *
     * 
     *
     * @param  \Agave\Client\Model\JobRequest $body The JSON description of the job to submit. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitJobAsync($body, $naked = 'true')
    {
        return $this->submitJobAsyncWithHttpInfo($body, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitJobAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Agave\Client\Model\JobRequest $body The JSON description of the job to submit. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitJobAsyncWithHttpInfo($body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Job';
        $request = $this->submitJobRequest($body, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submitJob'
     *
     * @param  \Agave\Client\Model\JobRequest $body The JSON description of the job to submit. (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function submitJobRequest($body, $naked = 'true')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling submitJob'
            );
        }

        $resourcePath = '/jobs/v2/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateJobPermission
     *
     * @param  string $job_id The id of the job for which the permissions will be updated (required)
     * @param  string $username The user for whom the permission will be udpated (required)
     * @param  \Agave\Client\Model\Permission $body The permission to update (required)
     * @param  bool $naked naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Agave\Client\Model\Permission
     */
    public function updateJobPermission($job_id, $username, $body, $naked = 'true')
    {
        list($response) = $this->updateJobPermissionWithHttpInfo($job_id, $username, $body, $naked);
        return $response;
    }

    /**
     * Operation updateJobPermissionWithHttpInfo
     *
     * @param  string $job_id The id of the job for which the permissions will be updated (required)
     * @param  string $username The user for whom the permission will be udpated (required)
     * @param  \Agave\Client\Model\Permission $body The permission to update (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \Agave\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Agave\Client\Model\Permission, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateJobPermissionWithHttpInfo($job_id, $username, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Permission';
        $request = $this->updateJobPermissionRequest($job_id, $username, $body, $naked);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Agave\Client\Model\Permission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateJobPermissionAsync
     *
     * 
     *
     * @param  string $job_id The id of the job for which the permissions will be updated (required)
     * @param  string $username The user for whom the permission will be udpated (required)
     * @param  \Agave\Client\Model\Permission $body The permission to update (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateJobPermissionAsync($job_id, $username, $body, $naked = 'true')
    {
        return $this->updateJobPermissionAsyncWithHttpInfo($job_id, $username, $body, $naked)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateJobPermissionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $job_id The id of the job for which the permissions will be updated (required)
     * @param  string $username The user for whom the permission will be udpated (required)
     * @param  \Agave\Client\Model\Permission $body The permission to update (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateJobPermissionAsyncWithHttpInfo($job_id, $username, $body, $naked = 'true')
    {
        $returnType = '\Agave\Client\Model\Permission';
        $request = $this->updateJobPermissionRequest($job_id, $username, $body, $naked);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateJobPermission'
     *
     * @param  string $job_id The id of the job for which the permissions will be updated (required)
     * @param  string $username The user for whom the permission will be udpated (required)
     * @param  \Agave\Client\Model\Permission $body The permission to update (required)
     * @param  bool $naked (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateJobPermissionRequest($job_id, $username, $body, $naked = 'true')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling updateJobPermission'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling updateJobPermission'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateJobPermission'
            );
        }

        $resourcePath = '/jobs/v2/{jobId}/pems/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($naked !== null) {
            $queryParams['naked'] = ObjectSerializer::toQueryValue($naked);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
